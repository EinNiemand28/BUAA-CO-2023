## Logisim单周期CPU设计文档

### CPU设计方案综述

#### 总体设计概述

使用logisim设计一个32位单周期处理器, 支持指令集为`add, sub, ori, lw, sw, beq, lui, nop`. 其中：

- `nop`为空指令, 机器码为`0x00000000`, 不进行任何有效行为
- `add, sub`为不支持溢出的无符号加减法

#### 数据通路设计

| 指令 | Adder_A | Adder_B | NPC                    | IM_Addr        | Reg1   | Reg2             | Wreg | Wdata  | ALU_A        | ALU_B    | DM_Addr     | DM_Wdata                        | Sign_ext | Nadd_A | Nadd_B      | Jump                            |
| ---- | ------- | ------- | ---------------------- | -------------- | ------ | ---------------- | ---- | ------ | ------------ | -------- | ----------- | ------------------------------- | -------- | ------ | ----------- | ------------------------------- |
| ALL  | PC      | 4       | Adder\|Nadd\|Jump\|$ra | ALU\|DM\|Adder | Rdata1 | Rdata2\|Sign_ext | ALU  | Rdata2 | offset/imm16 | Adder    | Sign_ext<<2 | IM_Addr[31:28]\|\|Instr26\|\|00 |          |        |             |                                 |
| R    | PC      | 4       | Adder                  | PC             | rs     | rt               | rd   | ALU    | Rdata1       | Rdata2   |             |                                 |          |        |             |                                 |
| lw   | PC      | 4       | Adder                  | PC             | rs     |                  | rt   | DM     | Rdata1       | Sign_ext | ALU         |                                 | offset   |        |             |                                 |
| sw   | PC      | 4       | Adder                  | PC             | rs     | rt               |      |        | Rdata1       | Sign_ext | ALU         | Rdata2                          | offset   |        |             |                                 |
| B    | PC      | 4       | Nadd                   | PC             | rs     | rt               |      |        | Rdata1       | Rdata2   |             |                                 | offset   | Adder  | Sign_ext<<2 |                                 |
| beq  | PC      | 4       | Nadd                   | PC             | rs     | rt               |      |        | Rdata1       | Rdata2   |             |                                 | offset   | Adder  | Sign_ext<<2 |                                 |
| R-I  | PC      | 4       | Adder                  | PC             | rs     |                  | rt   | ALU    | Rdata1       | Zero_ext |             |                                 | imm16    |        |             |                                 |
| ori  | PC      | 4       | Adder                  | PC             | rs     |                  | rt   | ALU    | Rdata1       | Zero_ext |             |                                 | imm16    |        |             |                                 |
| lui  | PC      | 4       | Adder                  | PC             |        |                  | rt   | ALU    |              | Zero_ext |             |                                 | imm16    |        |             |                                 |
| j    | PC      | 4       | Jump                   | PC             |        |                  |      |        |              |          |             |                                 |          |        |             | IM_Addr[31:28]\|\|Instr26\|\|00 |
| jal  | PC      | 4       | Jump                   | PC             |        |                  | $ra  | Adder  |              |          |             |                                 |          |        |             | IM_Addr[31:28]\|\|Instr26\|\|00 |
| jr   | PC      | 4       | $ra                    | PC             | rs     |                  |      |        |              |          |             |                                 |          |        |             |                                 |

#### 关键模块定义

1. IFU

    1. 端口定义

        |    信号名    | 方向 | 描述                                                         |
        | :----------: | :--: | ------------------------------------------------------------ |
        |     clk      |  I   | 时钟信号                                                     |
        |    reset     |  I   | 异步复位信号, 将PC置为0x00003000<br>1: 复位信号有效<br>0: 复位信号无效 |
        |    branch    |  I   | B类指令跳转信号<br>1: 需要进行B类跳转<br>0: 不需要进行B类跳转 |
        | Offset[31:0] |  I   | 地址偏移量, 用于b类指令跳转                                  |
        | Instr[31:0]  |  O   | 输出当前正在执行的指令                                       |
        |  PC+4[31:0]  |  O   | 输出PC+4的值                                                 |

    2. 功能定义

        | 序号 |    功能    | 描述                                                         |
        | :--: | :--------: | :----------------------------------------------------------- |
        |  1   |    复位    | 当reset信号有效时, 将PC重置为0x00003000 (PC寄存器的值置为0x00000000) |
        |  2   | 写PC寄存器 | 时钟信号上升沿到来时, 将下一条指令的地址写入PC寄存器         |
        |  3   |   取指令   | 根据当前的PC读出对应的指令并输出到Instr端口                  |

2. GRF

    1. 端口定义

        |  信号名   | 方向 | 描述                                                         |
        | :-------: | :--: | ------------------------------------------------------------ |
        |    clk    |  I   | 时钟信号                                                     |
        |   reset   |  I   | 异步复位信号, 将32个寄存器中的值全部清零<br>1: 复位信号有效<br>0: 复位信号无效 |
        |    WE     |  I   | 写使能信号<br>1: 可向GRF中写入数据<br>0: 不能向GRF中写入数据 |
        |  A1[4:0]  |  I   | 5 位地址输入信号，指定 32 个寄存器中的一个，将其中存储的数据读出到RD1 |
        |  A2[4:0]  |  I   | 5 位地址输入信号，指定 32 个寄存器中的一个，将其中存储的数据读出到 RD2 |
        |  A3[3:0]  |  I   | 5位地址输入信号，指定 32 个寄存器中的一个作为写入的目标寄存器 |
        | WD[31:0]  |  I   | 数据输入信号                                                 |
        | RD1[31:0] |  O   | 输出A1指定的寄存器中的32位数据                               |
        | RD2[31:0] |  O   | 输出A2指定的寄存器中的32位数据                               |

    2. 功能定义

        | 序号 |  功能  | 描述                                                       |
        | :--: | :----: | ---------------------------------------------------------- |
        |  1   |  复位  | reset信号有效时, 将所有寄存器存储的数值清零                |
        |  2   | 读数据 | 读出A1, A2地址对应寄存器中所存储的数据到RD1, RD2           |
        |  3   | 写数据 | 当WE 有效且时钟上升沿来临时, 将 WD 写入A3 所对应的寄存器中 |

3. ALU

    1. 端口定义

        |    信号名    | 方向 | 描述                                                         |
        | :----------: | :--: | ------------------------------------------------------------ |
        |  SrcA[31:0]  |  I   | 参与运算的第一个数                                           |
        |  SrcB[31:0]  |  I   | 参与运算的第二个数                                           |
        |  shamt[4:0]  |  I   | 移位数                                                       |
        |  ALUop[2:0]  |  I   | 决定ALU所做操作类型<br>000: 无符号加<br>001: 无符号减<br>010: 与<br>011: 或<br>100: 逻辑左移<br>101: 加载SrcB至高位 |
        |    equal     |  O   | 判断相等信号<br>1: SrcA == SrcB<br>0: SrcA != SrcB           |
        | result[31:0] |  O   | 输出ALU计算结果                                              |

    2. 功能定义

        | 序号 |       功能       | 描述                           |
        | :--: | :--------------: | ------------------------------ |
        |  1   |     无符号加     | result = SrcA + SrcB           |
        |  2   |     无符号减     | result = SrcA - SrcB           |
        |  3   |        与        | result = SrcA & SrcB           |
        |  4   |        或        | result = SrcA \| SrcB          |
        |  5   |     逻辑左移     | result = SrcB << shamt         |
        |  6   | 加载立即数至高位 | result = {SrcB[15:0], {16{0}}} |

4. DM

    1. 端口定义

        |   信号名   | 方向 | 描述                                                 |
        | :--------: | :--: | ---------------------------------------------------- |
        |    clk     |  I   | 时钟信号                                             |
        |   reset    |  I   | 异步复位信号<br>1: 复位信号有效<br>0: 复位信号无效   |
        |     WE     |  I   | 写使能信号<br>1: 可向DM中写入数据<br>0: 不可写入数据 |
        | Addr[11:0] |  I   | 12位地址信号输入信号, 指向DM中某个存储单元           |
        |  WD[31:0]  |  I   | 待写入的数据                                         |
        |  RD[31:0]  |  O   | 输出Addr指定的存储单元中的数据                       |

    2. 功能定义

        | 序号 |  功能  | 描述                                                         |
        | :--: | :----: | ------------------------------------------------------------ |
        |  1   |  复位  | reset信号有效时, 将DM存储的数据清零                          |
        |  2   | 读数据 | 读出Addr地址对应的存储单元中的数据到RD                       |
        |  3   | 写数据 | 当WE 有效且时钟上升沿来临时, 将 WD 写入Addr地址所对应的存储单元中 |

5. EXT

    1. 端口定义

        |   信号名    | 方向 | 描述                                                 |
        | :---------: | :--: | ---------------------------------------------------- |
        | imm16[15:0] |  I   | 待扩展的16位立即数                                   |
        |    extOp    |  I   | 扩展选择信号<br>1: 进行符号扩展<br>0: 进行无符号扩展 |
        | imm32[31:0] |  O   | 扩展后的32位立即数                                   |

    2. 功能定义

        | 序号 |    功能    | 描述                               |
        | :--: | :--------: | ---------------------------------- |
        |  1   | 无符号扩展 | extOp = 0时, 对imm16进行无符号扩展 |
        |  2   |  符号扩展  | extOp = 1时, 对imm16进行符号扩展   |

6. Controller

    1. 端口定义

        |    信号名     | 方向 | 描述                                                         |
        | :-----------: | :--: | ------------------------------------------------------------ |
        |    op[5:0]    |  I   | Instr[31:25]6位控制信号                                      |
        |  funct[5:0]   |  I   | Instr[5:0]6位控制信号                                        |
        |    RegDst     |  O   | GRF中A3接口选择信号<br>1: 接入GPR[rt]<br>0: 接入GPR[rd]      |
        |     Jump      |  O   | j/jal指令信号<br>1: 信号有效<br>0: 信号无效                  |
        |    LinkRa     |  O   | jal指令跳转链接信号, 选择是否写入$ra寄存器<br/>1: Jal指令信号有效, 执行链接\$ra操作<br>0: 信号无效 |
        |      Jr       |  O   | jr指令信号<br>1: Jr指令信号有效<br>0: 无效                   |
        | BranchOp[2:0] |  O   | B类跳转指令选择信号                                          |
        |   MemtoReg    |  O   | 写入GRF中数据选择信号<br>1: 数据来自DM<br>0: 来自ALU         |
        |   RegWrite    |  O   | GRF写使能信号<br>1: 可向GRF中写入数据<br>0: 不可写入数据     |
        |   MemWrite    |  O   | DM写使能信号<br>1: 可向DM中写入数据<br>0: 不可写入数据       |
        |  SignExtend   |  O   | 16位立即数符号扩展信号<br>1: 进行符号扩展<br>0: 进行零扩展   |
        |    ALUSrc     |  O   | ALU中SrcB端口数据选择信号<br>1: 数据来自立即数扩展<br>0: 数据来自GRF中的RD2 |
        |  ALUop[2:0]   |  O   | ALU功能选择信号                                              |

    2. 真值表

        | 端口       | addu(add) | subu(sub) | ori    | lui    | lw     | sw     | beq    | j      | jal    | sll    | jr     |
        | ---------- | --------- | --------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
        | op         | 000000    | 000000    | 001101 | 001111 | 100011 | 101011 | 000100 | 000010 | 000011 | 000000 | 000000 |
        | funct      | 100000    | 100010    |        |        |        |        |        |        |        | 000000 | 001000 |
        | RegDst     | 0         | 0         | 1      | 1      | 1      | 1      | 1      | 1      | 1      | 0      | 0      |
        | Jump       | 0         | 0         | 0      | 0      | 0      | 0      | 0      | 1      | 1      | 0      | 0      |
        | LinkRa     | 0         | 0         | 0      | 0      | 0      | 0      | 0      | 0      | 1      | 0      | 0      |
        | Jr         | 0         | 0         | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 1      |
        | Branch     | 0         | 0         | 0      | 0      | 0      | 0      | 1      | 0      | 0      | 0      | 0      |
        | MemtoReg   | 0         | 0         | 0      | 0      | 1      | 0      | 0      | 0      | 0      | 0      | 0      |
        | RegWrite   | 1         | 1         | 1      | 1      | 1      | 0      | 0      | 0      | 1      | 1      | 0      |
        | MemWrite   | 0         | 0         | 0      | 0      | 0      | 1      | 0      | 0      | 0      | 0      | 0      |
        | SignExtend | 0         | 0         | 0      | 0      | 1      | 1      | 1      | 0      | 0      | 0      | 0      |
        | ALUSrc     | 0         | 0         | 1      | 1      | 1      | 1      | 0      | 0      | 0      | 0      | 0      |
        | ALUop      | 000       | 001       | 011    | 101    | 000    | 000    | 000    | 000    | 000    | 000    | 000    |

7. CheckBranch

    1. 端口定义

        |    信号名     | 方向 | 描述                                                         |
        | :-----------: | :--: | ------------------------------------------------------------ |
        | BranchOp[2:0] |  I   | 表示是何种B类指令<br>001: bgez, bltz<br>010: bgtz<br>011: blez<br>100: bne<br>101: beq |
        |     equal     |  I   | 判断相等信号<br>1: GPR[rs] == GPR[rt]<br>0: GPR[rs] != GPR[rt] |
        |   rs[31:0]    |  I   | 待比较操作数                                                 |
        |   exOP[4:0]   |  I   | Instr[20:16], 用于区分bgez, bltz                             |
        |    Branch     |  O   | 判断跳转信号<br>1: 跳转<br>0: 不跳转                         |

        


### 测试方案

>#### 采用自动化测试



#### 数据生成思路

- 开始先用`ori`给31个寄存器随机赋值

- 然后生成10组标签`test0`,`end_test0` $\cdots$ `test9`,`end_test9`, 方便之后进行`beq`跳转

- 每组$test$中随机生成除`beq`指令外的20条指令

- 20条指令生成后, 进行4次随机的`beq`指令的生成, 跳转标签为`end_test(rand() % 10)`

    接着进行一次能够稳定跳转的`beq`指令生成, 具体操作为将随机指定的两个寄存器赋相同的随机数值

    ```cpp
    void beq(int i) {
    	int rs = rand() % 32;
    	int rt = rand() % 32;
    	printf("beq	$%d, $%d, end_test%d\n", rs, rt, i);
    }
    void Beq(int i) {
    	int rs = rand() % 32;
    	int rt = rand() % 32;
    	int imm = Random(0, 0xffff);
    	ori(0, rs, imm);
    	ori(0, rt, imm);
    	printf("beq $%d, $%d, end_test%d\n", rs, rt, i); 
    }
    ```
    
- 最后在末尾生成一次`beq $0, $0, begin` (`begin`标签设置在最开始)

- 需要注意的点是**16位立即数的生成, 要避免产生扩展指令**

### 测试步骤

- 运行`make.cpp`生成`test.asm`

- 命令行运行MARS生成机器码文件

    ```
    java -jar mars.jar a mc CompactDataAtZero dump .text HexText out.txt test.asm
    ```

- 将机器码分别导入自己的`cpu.circ`和同学的`cpu2.circ`中的ROM

- 命令行运行logisim生出输出文件，并fc比较

    ```
    java -jar logisim-generic-2.7.1.jar cpu.circ -tty table > output.txt
    java -jar logisim-generic-2.7.1.jar cpu2.circ -tty table > output2.txt
    ```

#### 测试结果

![image-20231029182226523](C:\Users\pengzhengyu\AppData\Roaming\Typora\typora-user-images\image-20231029182226523.png)

### 思考题

1. 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

    >状态储存: GRF, DM
    >
    >状态转移: IFU, EXT, ALU, Controller

2. 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

    >合理.
    >
    >IM作为指令存储单元, 在被导入机器码后执行指令过程中, 其中的指令不应被更改, 所以可以使用具有只读功能的ROM.
    >
    >DM则同理, 其中储存数据需要不断被写入、读出, 故使用可读可写的RAM.
    >
    >GRF作为寄存器堆, 使用Register实现是合理的, 且符合它需要读写速度高的需求.

3. 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

    >额外设计`BranchCheck`模块, 用于区分并判断各种B类跳转信号, 包括`beq`, `bne`, `bgez`, `blez`, `bgtz`, `bltz`.
    >
    >设计思路: 
    >
    >- 首先由`Controller`模块得到的`BranchOp`判断是何种B类跳转信号
    >- 然后根据指令手册再添加`equal`, `GPR[rs]`, `exOP`(区分`Instr[31:26]`相同的`bgez`,`bltz`指令)端口即可

4. 事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

    >因为`nop`指令的机器码为`00000000`, 相当于`sll $0, $0, $0`, 而0号寄存器的值不会被改变, 故不会产生任何影响.
    >
    >同样, 即使cpu没有实现`sll`指令操作, `nop`也不会产生任何控制信号, 不会造成影响.

5. 阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

    >测试覆盖了所有指令, 但是没有覆盖所有寄存器,
    >
    >同时数据的范围比较有限, `beq`跳转次数比较少, 没有向前跳转过.