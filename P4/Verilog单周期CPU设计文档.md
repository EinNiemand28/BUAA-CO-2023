# Verilog单周期CPU设计文档

## CPU设计方案综述

### 总体设计概述

使用$\cal{Verilog}$设计一个32位$\cal{MIPS}$单周期处理器, 不考虑延迟槽, 支持23条指令, 包括4条R型指令, 16条I型指令, 2条J型指令, `nop`.

1. R型指令
    1. 算数指令: `add, sub`
    2. 移位指令: `sll`
    3. 跳转指令: `jr`
2. I型指令
    1. 算数指令: `ori, lui`
    2. B类跳转指令: `bgez, bltz, bgtz, blez, bne, beq`
    3. 访存指令: `lw, lh, lhu, lb, lbu, sw, sh, sb`
3. J型指令
    1. 跳转指令: `j, jal`

 其中: 

- `nop`为空指令, 机器码为`0x00000000`, 不进行任何有效行为
- `add, sub`为不支持溢出的无符号加减法

### 数据通路设计

| 指令 | Adder_A | Adder_B | NPC                   | IM_Addr | Reg1 | Reg2 | Wreg         | Wdata          | ALU_A  | ALU_B       | DM_Addr | DM_Wdata | Sign_ext     | Nadd_A | Nadd_B      | Jump                            |
| ---- | ------- | ------- | --------------------- | ------- | ---- | ---- | ------------ | -------------- | ------ | ----------- | ------- | -------- | ------------ | ------ | ----------- | ------------------------------- |
| ALL  | PC      | 4       | Adder\|Nadd\|Jump\|rs | PC      | rs   | rt   | rt\|rd\|\$ra | ALU\|DM\|Adder | Rdata1 | Rdata2\|Ext | ALU     | Rdata2   | offset/imm16 | Adder  | Ext         | IM_Addr[31:28]\|\|Instr26\|\|00 |
| R    | PC      | 4       | Adder                 | PC      | rs   | rt   | rd           | ALU            | Rdata1 | Rdata2      |         |          |              |        |             |                                 |
| lw   | PC      | 4       | Adder                 | PC      | rs   |      | rt           | DM             | Rdata1 | Sign_ext    | ALU     |          | offset       |        |             |                                 |
| sw   | PC      | 4       | Adder                 | PC      | rs   | rt   |              |                | Rdata1 | Sign_ext    | ALU     | Rdata2   | offset       |        |             |                                 |
| B    | PC      | 4       | Nadd                  | PC      | rs   | rt   |              |                | Rdata1 | Rdata2      |         |          | offset       | Adder  | Sign_ext<<2 |                                 |
| beq  | PC      | 4       | Nadd                  | PC      | rs   | rt   |              |                | Rdata1 | Rdata2      |         |          | offset       | Adder  | Sign_ext<<2 |                                 |
| R-I  | PC      | 4       | Adder                 | PC      | rs   |      | rt           | ALU            | Rdata1 | Zero_ext    |         |          | imm16        |        |             |                                 |
| ori  | PC      | 4       | Adder                 | PC      | rs   |      | rt           | ALU            | Rdata1 | Zero_ext    |         |          | imm16        |        |             |                                 |
| lui  | PC      | 4       | Adder                 | PC      |      |      | rt           | ALU            |        | Zero_ext    |         |          | imm16        |        |             |                                 |
| j    | PC      | 4       | Jump                  | PC      |      |      |              |                |        |             |         |          |              |        |             | IM_Addr[31:28]\|\|Instr26\|\|00 |
| jal  | PC      | 4       | Jump                  | PC      |      |      | $ra          | Adder          |        |             |         |          |              |        |             | IM_Addr[31:28]\|\|Instr26\|\|00 |
| jr   | PC      | 4       | rs                    | PC      | rs   |      |              |                |        |             |         |          |              |        |             |                                 |

### 关键模块定义

#### IFU

1. 端口定义

    | 信号名       | 方向 | 描述                                                         |
    | ------------ | ---- | :----------------------------------------------------------- |
    | clk          | I    | 时钟信号                                                     |
    | reset        | I    | 同步复位信号, 将PC置为0x00003000<br>1: 复位信号有效<br>0: 复位信号无效 |
    | NextPC[31:0] | I    | 下一个PC值                                                   |
    | PC[31:0]     | O    | 当前PC值                                                     |
    | Instr[31:0]  | O    | 当前指令                                                     |

2. 功能定义

    | 序号 | 功能     | 描述                 |
    | ---- | -------- | :------------------- |
    | 1    | 取指令   | 取出当前PC对应的指令 |
    | 2    | 更新PC值 | PC <= NextPC         |

#### NPC

1. 端口定义

    | 信号名          | 方向 | 描述                            |
    | --------------- | ---- | :------------------------------ |
    | PC[31:0]        | I    | 当前PC值                        |
    | Instr26[25:0]   | I    | J/Jar指令的26位立即数           |
    | Offset[31:0]    | I    | B类跳转指令经过扩展的地址偏移量 |
    | RegToJump[31:0] | I    | Jr指令跳转地址                  |
    | Jump            | I    | J/Jal指令信号                   |
    | Branch          | I    | B类指令信号                     |
    | Jr              | I    | Jr指令信号                      |
    | NextPC[31:0]    | O    | 下一个PC值                      |
    | PC4[31:0]       | O    | PC+4的值                        |

2. 功能定义

    | 序号 | 功能         | 描述                           |
    | ---- | ------------ | :----------------------------- |
    | 1    | 计算NextPC值 | 根据当前指令和PC计算下一个PC值 |
    | 2    | 计算PC+4的值 | PC4输出Jr写入寄存器中的数据    |

#### GRF

1. 端口定义

    | 信号名    | 方向 | 描述                                                         |
    | --------- | ---- | :----------------------------------------------------------- |
    | clk       | I    | 时钟信号                                                     |
    | reset     | I    | 同步复位信号, 将32个寄存器中的值全部清零<br/>1: 复位信号有效<br/>0: 复位信号无效 |
    | WE        | I    | 写使能信号<br>1: 可向GRF中写入数据<br>0: 不能向GRF中写入数据 |
    | A1[4:0]   | I    | 5 位地址输入信号，指定 32 个寄存器中的一个，将其中存储的数据读出到RD1 |
    | A2[4:0]   | I    | 5 位地址输入信号，指定 32 个寄存器中的一个，将其中存储的数据读出到 RD2 |
    | A3[3:0]   | I    | 5位地址输入信号，指定 32 个寄存器中的一个作为写入的目标寄存器 |
    | WD[31:0]  | I    | 写入数据信号                                                 |
    | RD1[31:0] | O    | 输出A1指定的寄存器中的32位数据                               |
    | RD2[31:0] | O    | 输出A2指定的寄存器中的32位数据                               |

2. 功能定义

    | 序号 | 功能   | 描述                                                         |
    | ---- | ------ | :----------------------------------------------------------- |
    | 1    | 复位   | 时钟信号处于信号上升沿且reset信号有效时, 将所有寄存器存储的数值清零 |
    | 2    | 读数据 | 读出A1, A2地址对应寄存器中所存储的数据到RD1, RD2             |
    | 3    | 写数据 | 当WE 有效且时钟上升沿来临时, 将 WD 写入A3 所对应的寄存器中   |

#### ALU

1. 端口定义

    | 信号名       | 方向 | 描述                                                         |
    | ------------ | ---- | :----------------------------------------------------------- |
    | SrcA[31:0]   | I    | 参与运算的第一个数                                           |
    | SrcB[31:0]   | I    | 参与运算的第二个数                                           |
    | shamt[4:0]   | I    | 移位数                                                       |
    | ALUOp[2:0]   | I    | 决定ALU所做操作类型<br>000: 无符号加<br>001: 无符号减<br>010: 与<br>011: 或<br>100: 逻辑左移<br>101: 加载SrcB至高位 |
    | equal        | O    | 判断相等信号<br>1: SrcA == SrcB<br>0: SrcA != SrcB           |
    | result[31:0] | O    | 输出ALU计算结果                                              |

2. 功能定义

    | 序号 | 功能             | 描述                           |
    | ---- | ---------------- | :----------------------------- |
    | 1    | 无符号加         | result = SrcA + SrcB           |
    | 2    | 无符号减         | result = SrcA - SrcB           |
    | 3    | 与               | result = SrcA & SrcB           |
    | 4    | 或               | result = SrcA \| SrcB          |
    | 5    | 逻辑左移         | result = SrcB << shamt         |
    | 6    | 加载立即数至高位 | result = {SrcB[15:0], {16{0}}} |

#### DM

1. 端口定义

    | 信号名     | 方向 | 描述                                                         |
    | ---------- | ---- | :----------------------------------------------------------- |
    | clk        | I    | 时钟信号                                                     |
    | reset      | I    | 同步复位信号<br>1: 复位信号有效<br>0: 复位信号无效           |
    | WE         | I    | 写使能信号<br>1: 可向DM中写入数据<br>0: 不可写入数据         |
    | Addr[31:0] | I    | 地址输入信号, 指向DM中某个存储单元                           |
    | WD[31:0]   | I    | 待写入的数据                                                 |
    | MemOp[2:0] | I    | 访存功能选择信号<br>000: lw<br>001: lh<br>010: lhu<br>011: lb<br>100: lbu<br>101: sw<br>110: sh<br>111: sb |
    | RD[31:0]   | O    | 输出Addr指定的存储单元中的数据                               |

2. 功能定义

    | 序号 | 功能   | 描述                                                         |
    | ---- | ------ | :----------------------------------------------------------- |
    | 1    | 复位   | 时钟信号处于上升沿且reset信号有效时, 将DM存储的数据清零      |
    | 2    | 读数据 | 根据MemOp读出Addr地址对应的存储单元中的数据到RD              |
    | 3    | 写数据 | 当WE 有效且时钟上升沿来临时, 根据MemOp将 WD 写入Addr地址所对应的存储单元中 |

#### EXT

1. 端口定义

    | 信号名      | 方向 | 描述                                                   |
    | ----------- | ---- | :----------------------------------------------------- |
    | imm16[15:0] | I    | 待扩展的16位立即数                                     |
    | ExtOp       | I    | 扩展选择信号<br/>1: 进行符号扩展<br/>0: 进行无符号扩展 |
    | imm32[31:0] | O    | 扩展后的32位立即数                                     |

2. 功能定义

    | 序号 | 功能       | 描述                               |
    | ---- | ---------- | :--------------------------------- |
    | 1    | 无符号扩展 | ExtOp = 0时, 对imm16进行无符号扩展 |
    | 2    | 符号扩展   | ExtOp = 1时, 对imm16进行符号扩展   |

#### Controller

1. 端口定义

    | 信号名        | 方向 | 描述                                                         |
    | ------------- | ---- | :----------------------------------------------------------- |
    | op[5:0]       | I    | Instr[31:25]6位控制信号                                      |
    | funct[5:0]    | I    | Instr[5:0]6位控制信号                                        |
    | RegDst[1:0]   | O    | GRF中A3接口选择信号<br>00: 接入GPR[rd]<br>01: 接入GPR[rt]<br>10: 接入GPR[31] |
    | Jump          | O    | j/jal指令信号<br>1: 信号有效<br>0: 信号无效                  |
    | Jr            | O    | jr指令信号<br>1: Jr指令信号有效<br>0: 无效                   |
    | BranchOp[2:0] | O    | B类跳转指令选择信号                                          |
    | RegSrc[1:0]   | O    | 写入GRF中数据选择信号<br>00: 来自ALU<br>01: 数据来自DM<br>10: 数据来自PC4 (Jal) |
    | RegWrite      | O    | GRF写使能信号<br>1: 可向GRF中写入数据<br>0: 不可写入数据     |
    | MemWrite      | O    | DM写使能信号<br>1: 可向DM中写入数据<br>0: 不可写入数据       |
    | SignExtend    | O    | 16位立即数符号扩展信号<br>1: 进行符号扩展<br>0: 进行零扩展   |
    | ALUSrc        | O    | ALU中SrcB端口数据选择信号<br>1: 数据来自立即数扩展<br>0: 数据来自GRF中的RD2 |
    | ALUOp[2:0]    | O    | ALU功能选择信号                                              |
    | MemOp[2:0]    | O    | DM功能选择信号                                               |

2. 真值表

    |           | op     | funct<br>Instr[20:16] | RegDst | Jump | Jr   | BranchOp | RegSrc | RegWrite | MemWrite | SignExtend | ALUSrc | ALUOp | MemOp |
    | --------- | ------ | :-------------------: | ------ | ---- | ---- | -------- | ------ | -------- | -------- | ---------- | ------ | ----- | ----- |
    | add(addu) | 000000 |        100000         | 00     | 0    | 0    | 000      | 00     | 1        | 0        | 0          | 0      | 000   | 000   |
    | sub(subu) | 000000 |        100010         | 00     | 0    | 0    | 000      | 00     | 1        | 0        | 0          | 0      | 001   | 000   |
    | sll       | 000000 |        000000         | 00     | 0    | 0    | 000      | 00     | 1        | 0        | 0          | 0      | 100   | 000   |
    | jr        | 000000 |        001000         | 00     | 0    | 1    | 000      | 00     | 0        | 0        | 0          | 0      | 000   | 000   |
    | ori       | 001101 |                       | 01     | 0    | 0    | 000      | 00     | 1        | 0        | 0          | 1      | 011   | 000   |
    | lui       | 001111 |                       | 01     | 0    | 0    | 000      | 00     | 1        | 0        | 0          | 1      | 101   | 000   |
    | beq       | 000100 |                       | 01     | 0    | 0    | 101      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | bne       | 000101 |                       | 01     | 0    | 0    | 100      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | bgtz      | 000111 |                       | 01     | 0    | 0    | 010      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | blez      | 000110 |                       | 01     | 0    | 0    | 011      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | bgez      | 000001 |         00001         | 01     | 0    | 0    | 001      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | bltz      | 000001 |         00000         | 01     | 0    | 0    | 001      | 00     | 0        | 0        | 1          | 0      | 000   | 000   |
    | lw        | 100011 |                       | 01     | 0    | 0    | 000      | 01     | 1        | 0        | 1          | 1      | 000   | 000   |
    | lh        | 100001 |                       | 01     | 0    | 0    | 000      | 01     | 1        | 0        | 1          | 1      | 000   | 001   |
    | lhu       | 100101 |                       | 01     | 0    | 0    | 000      | 01     | 1        | 0        | 1          | 1      | 000   | 010   |
    | lb        | 100000 |                       | 01     | 0    | 0    | 000      | 01     | 1        | 0        | 1          | 1      | 000   | 011   |
    | lbu       | 100100 |                       | 01     | 0    | 0    | 000      | 01     | 1        | 0        | 1          | 1      | 000   | 100   |
    | sw        | 101011 |                       | 01     | 0    | 0    | 000      | 00     | 0        | 1        | 1          | 1      | 000   | 101   |
    | sh        | 101001 |                       | 01     | 0    | 0    | 000      | 00     | 0        | 1        | 1          | 1      | 000   | 110   |
    | sb        | 101000 |                       | 01     | 0    | 0    | 000      | 00     | 0        | 1        | 1          | 1      | 000   | 111   |
    | jal       | 000011 |                       | 10     | 1    | 0    | 000      | 10     | 1        | 0        | 0          | 0      | 000   | 000   |
    | j         | 000010 |                       | 01     | 1    | 0    | 000      | 00     | 0        | 0        | 0          | 0      | 000   | 000   |

    

#### BranchControl

1. 端口定义

    | 信号名        | 方向 | 描述                                                         |
    | ------------- | ---- | :----------------------------------------------------------- |
    | BranchOp[2:0] | I    | 表示是何种B类指令<br>001: bgez, bltz<br>010: bgtz<br>011: blez<br>100: bne<br>101: beq |
    | equal         | I    | 判断相等信号<br>1: GPR[rs] == GPR[rt]<br>0: GPR[rs] != GPR[rt] |
    | rs[31:0]      | I    | 待比较操作数                                                 |
    | Judge         | I    | 区分bgez, bltz<br>1: Instr[20:16] = 00001<br>0: Instr[20:16] = 00000 |
    | Branch        | O    | 判断跳转信号<br>1: 跳转<br>0: 不跳转                         |

2. 功能定义

    | 序号 | 功能         | 描述                                           |
    | ---- | ------------ | :--------------------------------------------- |
    | 1    | 产生跳转信号 | 判断当前跳转指令是否满足跳转条件并输出对应信号 |

-----

## 测试方案

### 符悦同学的自动化测试脚本

#### [source](http://cscore.buaa.edu.cn/#/discussion_area/1075/1154/posts)

#### 测试结果

![image-20231105111740495](C:\Users\pengzhengyu\AppData\Roaming\Typora\typora-user-images\image-20231105111740495.png)

### 张栗瑞同学的自动化评测OJ

#### [source](http://cscore.buaa.edu.cn/#/discussion_area/1090/1361/posts)

#### 测试结果

![image-20231105112141763](C:\Users\pengzhengyu\AppData\Roaming\Typora\typora-user-images\image-20231105112141763.png)

## 思考题

1. 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？

    addr信号由ALU的运算结果截取而来.

    mips存储的基本单位是字, 而addr是字节寻址, 故应该对addr位数应该取[11:2]而非[9:0].

2. 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。

    ```verilog
    //代码示例
    //指令对应的控制信号如何取值
    assign SignExtend = lw | lh | lhu | lb | lbu | sw | sh | sb |
                            beq | bne | blez | bgtz | bgez_bltz;
    //控制信号每种取值所对应的指令
    assign MemOp = lh ? 3'd1 :
                       lhu ? 3'd2 :
                       lb ? 3'd3 :
                       lbu ? 3'd4 :
                       sw ? 3'd5 :
                       sh ? 3'd6 :
                       sb ? 3'd7 : 3'd0;
    ```

3. 在相应的部件中，复位信号的设计都是**同步复位**，这与 P3 中的设计要求不同。请对比**同步复位**与**异步复位**这两种方式的 reset 信号与 clk 信号优先级的关系。

    ```verilog
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ...
        end
    end
    //异步复位
    always @(posedge clk) begin
        if (reset) begin
            ...
        end
    end
    //同步复位
    
    //可以看出, 异步复位clk与reset优先级相同; 而同步复位优先级clk > reset
    ```

4. C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。

    阅读指令集可以发现, add和addu行为上的区别在于, addu忽略溢出, 而add则会抛出错误`SignalException(IntegerOverflow)`. 故忽略溢出时, 二者将等价. addi与addiu同理.
