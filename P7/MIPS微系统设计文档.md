# MIPS微系统设计文档

## 设计方案综述

### 总体设计概述

​	使用$\cal{Verilog}$在$\cal{P6}$的基础上设计一个支持中断和异常的$\cal{MIPS}$微系统. 顶层模块包括$\cal{CPU、Bridge、Timer0、Timer1}$共四个功能部件, 其中:

- 支持以下异常

    | ExcCode | 助记符  | 描述                                           |
    | ------- | ------- | :--------------------------------------------- |
    | 0       | Int     | 中断                                           |
    | 4       | AdEL    | 取数或取指时地址错误                           |
    | 5       | AdES    | 存数时地址错误                                 |
    | 8       | Syscall | 系统调用                                       |
    | 10      | RI      | 不认识的（或者非法的）指令码                   |
    | 12      | Ov      | 自陷形式的整数算术指令（例如 `add`）导致的溢出 |

- 中断信号由中断发生器和计时器产生, 来自$\cal{Time0、Time1、}$中断发生器的中断信号分别接入`HWInt[0:2]`, 只能通过指令`sb $0, 0x7f20($0)`访问中断发生器

- 通过系统桥$\cal{Bridge}$连接$\cal{CPU}$和外设, 系统桥传入对地址的访问请求后, 通过系统桥内部的转换代码, 将请求转变为对相应寄存器的读写操作. 地址空间设计如下

    | 条目                 | 地址或地址范围            |          备注          |
    | -------------------- | ------------------------- | :--------------------: |
    | 数据存储器           | `0x0000_0000∼0x0000_2FFF` |                        |
    | 指令存储器           | `0x0000_3000∼0x0000_6FFF` |                        |
    | PC 初始值            | `0x0000_3000`             |                        |
    | 异常处理程序入口地址 | `0x0000_4180`             |                        |
    | 计时器 0 寄存器地址  | `0x0000_7F00∼0x0000_7F0B` | 计时器 0 的 3 个寄存器 |
    | 计时器 1 寄存器地址  | `0x0000_7F10∼0x0000_7F1B` | 计时器 1 的 3 个寄存器 |
    | 中断发生器响应地址   | `0x0000_7F20∼0x0000_7F23` |                        |

- $\cal{CPU}$在$\cal{P6}$的基础上进行开发, 支持指令集为

    ```assembly
    nop, add, sub, and, or, slt, sltu, lui, sll
    addi, andi, ori
    lb, lh, lw, sb, sh, sw
    mult, multu, div, divu, mfhi, mflo, mthi, mtlo
    beq, bne, bgez, bltz, jal, jr, j
    mfc0, mtc0, eret, syscall
    ```

    - `eret`具有跳转的功能但是没有延迟槽
    - `syscall`需直接产生异常并进入内核态
    - 不会写入 $\cal{Cause}$, 但可能写入 $\cal{SR}$ 和 $\cal{EPC}$

![structure](D:\file\study\2023Autumn\computer_composition\experiment\p7\structure.svg)

### 顶层模块规格

```verilog
module mips(
    input clk,                    // 时钟信号
    input reset,                  // 同步复位信号
    input interrupt,              // 外部中断信号
    output [31:0] macroscopic_pc, // 宏观 PC

    output [31:0] i_inst_addr,    // IM 读取地址（取指 PC）
    input  [31:0] i_inst_rdata,   // IM 读取数据

    output [31:0] m_data_addr,    // DM 读写地址
    input  [31:0] m_data_rdata,   // DM 读取数据
    output [31:0] m_data_wdata,   // DM 待写入数据
    output [3 :0] m_data_byteen,  // DM 字节使能信号

    output [31:0] m_int_addr,     // 中断发生器待写入地址
    output [3 :0] m_int_byteen,   // 中断发生器字节使能信号

    output [31:0] m_inst_addr,    // M 级 PC

    output w_grf_we,              // GRF 写使能信号
    output [4 :0] w_grf_addr,     // GRF 待写入寄存器编号
    output [31:0] w_grf_wdata,    // GRF 待写入数据

    output [31:0] w_inst_addr     // W 级 PC
);
```

### 新增模块定义

#### BE

1. 端口定义

    | 信号名             | 方向 | 描述                 |
    | ------------------ | ---- | :------------------- |
    | Req                | I    | 进入处理程序请求信号 |
    | MemOp[3:0]         | I    | 存取功能选择信号     |
    | Addr[31:0]         | I    | 存取地址             |
    | ExcDMOv            | I    | 地址计算溢出信号     |
    | WriteData[31:0]    | I    | 待写入数据           |
    | m_data_byteen[3:0] | O    | 字节使能信号         |
    | m_data_wdata[31:0] | O    | 修正后待写入的数据   |
    | ExcAdES            | O    | AdES异常信号         |

2. 功能定义

    | 序号 | 功能     | 描述                                    |
    | ---- | -------- | :-------------------------------------- |
    | 1    | 存储数据 | 产生`m_data_byteen`和`m_data_wdata`信号 |
    | 2    | 异常判断 | 判断是否产生了存数异常                  |

#### DE

1. 端口定义

    | 信号名             | 方向 | 描述             |
    | ------------------ | ---- | :--------------- |
    | MemOp[3:0]         | I    | 存取功能选择信号 |
    | Addr[31:0]         | I    | 存取地址         |
    | m_data_rdata[31:0] | I    | 从DM中读取的数据 |
    | ExcDMOv            | I    | 地址计算溢出信号 |
    | ReadData[31:0]     | O    | 修正后的数据     |
    | ExcAdEL            | O    | AdEL异常信号     |

2. 功能定义

    | 序号 | 功能     | 描述                                   |
    | ---- | -------- | :------------------------------------- |
    | 1    | 读出数据 | 根据`m_data_rdata`得出写入寄存器的数据 |
    | 2    | 异常判断 | 判断是否产生了取数异常                 |

#### CP0

1. 端口定义

    | 信号           | 方向 | 描述             |
    | -------------- | ---- | :--------------- |
    | clk            | I    | 时钟信号         |
    | reset          | I    | 复位信号         |
    | WE             | I    | 写使能信号       |
    | CP0Add[4:0]    | I    | 寄存器地址       |
    | CP0In[31:0]    | I    | CP0 写入数据     |
    | CP0Out[31:0]   | O    | CP0 读出数据     |
    | VPC[31:0]      | I    | 受害 PC          |
    | BDIn           | I    | 是否是延迟槽指令 |
    | ExcCodeIn[4:0] | I    | 记录异常类型     |
    | HWInt[5:0]     | I    | 输入中断信号     |
    | EXCClr         | I    | 用来复位 EXL     |
    | EPCOut[31:0]   | O    | EPC 的值         |
    | Req            | O    | 进入处理程序请求 |

2. 功能定义

    | 序号 | 功能     | 描述                                       |
    | ---- | -------- | :----------------------------------------- |
    | 1    | 记录异常 | 利用内置的寄存器SR, Cause, EPC记录异常信息 |
    | 2    | 判定中断 | 根据内置寄存器决定中断能否产生             |

#### Bridge

1. 端口定义

    | 信号                    | 方向 | 描述                |
    | ----------------------- | ---- | :------------------ |
    | m_data_addr_temp[31:0]  | I    | CPU写入地址         |
    | m_data_wdata_temp[31:0] | I    | CPU写入数据         |
    | m_data_byteen_temp[3:0] | I    | CPU读写字节使能信号 |
    | m_data_rdata_temp[31:0] | O    | CPU读取的数据       |
    | m_data_addr[31:0]       | O    | DM 读写地址         |
    | m_data_wdata[31:0]      | O    | DM 待写入数据       |
    | m_data_byteen[3:0]      | O    | DM 字节使能信号     |
    | m_data_rdata[31:0]      | I    | DM 待写入数据       |
    | TC0Addr[31:0]           | O    | Timer0地址          |
    | TC0Din[31:0]            | O    | Timer0读入数据      |
    | TC0WE                   | O    | Timer0使能信号      |
    | TC0Dout[31:0]           | I    | Timer0输出数据      |
    | TC1Addr[31:0]           | O    |                     |
    | TC1Din[31:0]            | O    |                     |
    | TC1WE                   | O    |                     |
    | TC1Dout[31:0]           | I    |                     |

    

2. 功能定义

    | 序号 | 功能     | 描述                        |
    | ---- | -------- | :-------------------------- |
    | 1    | 信息处理 | 处理CPU和外设之间的信息交换 |

#### TC

​	由官方提供.

## 测试方案

### 姜涵章同学的coKiller

![image-20231210211743913](C:\Users\pengzhengyu\AppData\Roaming\Typora\typora-user-images\image-20231210211743913.png)

## 思考题

1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？

> >鼠标和键盘的输入信号可以产生不同的中断信号, CPU就可以进入中断处理程序对这些信息进行处理.

2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）

> >这样方便CPU的统一设计. 我认为可以, 这样可能会导致设计复杂、CPU的适用性降低.

3、为何与外设通信需要 Bridge？

> >外设的种类是无穷无尽的, 而 CPU 的指令集却是有限的. 为了让CPU 可以用统一的方法访问这些外设, 我们需要设计Bridge给CPU提供接口, 这样符合高内聚，低耦合的设计思想.

4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。

> >模式0会在计数结束后, 持续产生中断信号, 直至屏蔽中断或重新计数. 模式1倒计时为0后, 会重新读取preset寄存器的值并再次开始计数, 且只会产生一个周期的中断信号.
> >
> >![微信图片_20231217212706](D:\file\study\2023Autumn\computer_composition\experiment\p7\微信图片_20231217212706.jpg)

5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？

> >宏观PC会突然变成0或x. 暂停清空流水寄存器时应保存PC和BD信号.

6、为什么 `jalr` 指令为什么不能写成 `jalr $31, $31`？

> >如果该条指令的延迟槽内发生异常或需要响应中断, 则由于31号寄存器的值已经改变, 处理结束后返回再次执行该指令时, 会跳向不正确的$\cal{PC}$.
